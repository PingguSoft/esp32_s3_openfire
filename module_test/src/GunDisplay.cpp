#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>
#include <Wire.h>
#include "GunDisplay.h"

#define unpack_uint16(x)    ((x >> 0) & 0xff), ((x >> 8) & 0xff)
#define bitmap_width(x)     (x[0] | ((uint16_t)x[1] << 8))
#define bitmap_height(x)    (x[2] | ((uint16_t)x[3] << 8))

/// @brief Glyphs for common HUD elements
static const uint8_t number_0[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xd0, 0xe0, 0x00, 0x78, 0xe0, 0x00, 0xf8, 0xe0,
    0x00, 0xf8, 0xe0, 0x01, 0xb8, 0xe0, 0x01, 0xb8, 0xe0, 0x03, 0x38, 0xe0, 0x03, 0x38, 0xe0, 0x06,
    0x38, 0xe0, 0x06, 0x38, 0xe0, 0x0c, 0x38, 0xe0, 0x0c, 0x38, 0xe0, 0x18, 0x38, 0xe0, 0x18, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0xb8, 0xe0, 0x60, 0x38, 0xe0, 0x60, 0x38, 0xe0,
    0xc0, 0x38, 0xe0, 0xc0, 0x38, 0xe1, 0x80, 0x38, 0xe1, 0x80, 0x38, 0xe3, 0x00, 0x38, 0xe3, 0x00,
    0x38, 0xe6, 0x00, 0x38, 0xe6, 0x00, 0x38, 0xec, 0x00, 0x38, 0xec, 0x00, 0x38, 0xf8, 0x00, 0x38,
    0xf8, 0x00, 0x38, 0x5f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_1[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t number_2[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xd0, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x0f, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0x80, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0,
    0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0xe0, 0x00, 0x00, 0x5f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_3[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xd0, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x0f, 0xff, 0xb8, 0x1f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x1f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_4[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x10, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t number_5[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xc0, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0,
    0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0xef, 0xff, 0x80, 0x5f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x1f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_6[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xc0, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0,
    0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0xef, 0xff, 0x80, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0xb8, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xe0, 0x00, 0x38, 0x5f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_7[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0xc0, 0x00,
    0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x06,
    0x00, 0x00, 0x06, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00,
    0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00, 0x60, 0x00, 0x00,
    0xc0, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x06, 0x00, 0x00, 0x06, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x18, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t number_8[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xd0, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0xb8, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xe0, 0x00, 0x38, 0x5f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_9[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xd0, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x1f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t *numbers[] = {
    number_0,
    number_1,
    number_2,
    number_3,
    number_4,
    number_5,
    number_6,
    number_7,
    number_8,
    number_9
};

static const uint8_t lifeIcoSmall[] = {
    unpack_uint16(12), unpack_uint16(16),
    0xff, 0xf0, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x90, 0x90, 0xb9, 0xd0, 0xbf, 0xd0, 0xbf, 0xd0,
    0xbf, 0xd0, 0x9f, 0x90, 0x8f, 0x10, 0x86, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0xff, 0xf0
};

static const uint8_t lifeIcoLarge[] = {
    unpack_uint16(16), unpack_uint16(20),
    0xff, 0xff, 0xc0, 0x03, 0xbf, 0xfd, 0xa0, 0x05, 0xa0, 0x05, 0xa0, 0x05, 0xa4, 0x25, 0xae, 0x75,
    0xaf, 0xf5, 0xaf, 0xf5, 0xaf, 0xf5, 0xa7, 0xe5, 0xa3, 0xc5, 0xa1, 0x85, 0xa0, 0x05, 0xa0, 0x05,
    0xa0, 0x05, 0xbf, 0xfd, 0xc0, 0x03, 0xff, 0xff
};

static const uint8_t lifeBarBanner[] = {
    unpack_uint16(23), unpack_uint16(9),
    0xc1, 0xbf, 0x7e, 0xc1, 0xbf, 0x7e, 0xc1, 0xb8, 0x60, 0xc1, 0xb0, 0x60, 0xc1, 0xbe, 0x7c, 0xc1,
    0xbe, 0x60, 0xc1, 0xb0, 0x60, 0xfd, 0xb0, 0x7e, 0xfd, 0xb0, 0x7e
};

static const uint8_t lifeBarSmall[] = {
    unpack_uint16(59), unpack_uint16(9),
    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80
};

static const uint8_t lifeBarLarge[] = {
    unpack_uint16(106), unpack_uint16(13),
    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x3f, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0,
    0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xfe, 0x00
};

static const uint8_t reloadGlyph[] = {
    // RELOAD
};

// if only we could draw this vertically, sigh
static const uint8_t dividerLine[] = {
    unpack_uint16(1), unpack_uint16(48),
    0x40, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
    0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
    0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00
};

static const uint8_t upArrowGlyph[] = {
    unpack_uint16(9), unpack_uint16(5),
    0x08, 0x00, 0x14, 0x00, 0x22, 0x00, 0x41, 0x00, 0x80, 0x80
};

static const uint8_t downArrowGlyph[] = {
    unpack_uint16(9), unpack_uint16(5),
    0x80, 0x80, 0x41, 0x00, 0x22, 0x00, 0x14, 0x00, 0x08, 0x00
};

static const uint8_t btConnectIco[] = {
    unpack_uint16(10), unpack_uint16(17),
    0x18, 0x00, 0x1c, 0x00, 0x1e, 0x00, 0x1b, 0x00, 0xd9, 0x80, 0x78, 0xc0, 0x39, 0x80, 0x1b, 0x00,
    0x1e, 0x00, 0x1b, 0x00, 0x39, 0x80, 0x78, 0xc0, 0xd9, 0x80, 0x1b, 0x00, 0x1e, 0x00, 0x1c, 0x00,
    0x18, 0x00
};

static const uint8_t usbConnectIco[] = {
    unpack_uint16(10), unpack_uint16(17),
    0x3f, 0x00, 0x2d, 0x00, 0x2d, 0x00, 0x2d, 0x00, 0x7f, 0x80, 0xc0, 0xc0, 0x88, 0x40, 0x9c, 0x40,
    0x89, 0x40, 0xa9, 0x40, 0xaa, 0x40, 0xac, 0x40, 0x98, 0x40, 0x88, 0x40, 0x80, 0x40, 0xff, 0xc0,
    0x7f, 0x80
};

static const uint8_t gamepadIco[] = {
    unpack_uint16(18), unpack_uint16(12),
    0x38, 0x07, 0x00, 0x7d, 0xef, 0x80, 0x42, 0x10, 0x80, 0x80, 0x00, 0x40, 0x91, 0x22, 0x40, 0xb8,
    0x05, 0x40, 0x93, 0x32, 0x40, 0x84, 0xc8, 0x40, 0x84, 0xc8, 0x40, 0x87, 0x38, 0x40, 0x44, 0x08,
    0x80, 0x38, 0x07, 0x00
};

static const uint8_t mouseIco[] = {
    unpack_uint16(16), unpack_uint16(13),
    0x06, 0x00, 0x09, 0x03, 0x10, 0x84, 0x7c, 0x48, 0x92, 0x48, 0x92, 0x30, 0x92, 0x00, 0xfe, 0x00,
    0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0x44, 0x00, 0x38, 0x00
};

static const uint8_t mamehookIco[] = {
    unpack_uint16(21), unpack_uint16(16),
    0x00, 0x02, 0x08, 0x00, 0x06, 0x18, 0x00, 0x0e, 0x38, 0x00, 0x1a, 0x68, 0x00, 0x32, 0xc8, 0x00,
    0x63, 0x88, 0x00, 0xc3, 0x08, 0x01, 0x82, 0x08, 0x03, 0x00, 0x08, 0x06, 0x10, 0x08, 0x0c, 0x30,
    0x88, 0x18, 0x71, 0x88, 0x30, 0xb3, 0x88, 0x61, 0x35, 0x88, 0xc2, 0x39, 0x88, 0xfc, 0x31, 0xf8
};

static const uint8_t customSplashBanner[] = {
    unpack_uint16(80), unpack_uint16(16),
    0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xef, 0xf1, 0xff, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x03,
    0xfe, 0xef, 0xf9, 0xff, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xef, 0xf9, 0xc0, 0x7a, 0xf0,
    0x00, 0x00, 0x00, 0x03, 0x80, 0xee, 0x1d, 0xc0, 0x72, 0x73, 0xfc, 0x1f, 0x8f, 0xf3, 0x80, 0xee,
    0x0d, 0xc0, 0xe2, 0x3b, 0xfe, 0x3f, 0xcf, 0xfb, 0xfe, 0xee, 0x1d, 0xff, 0xff, 0xfb, 0x8f, 0x78,
    0xef, 0xfb, 0xfe, 0xef, 0xf9, 0xff, 0xe2, 0x3b, 0x87, 0x70, 0x6e, 0x7b, 0xfe, 0xef, 0xf9, 0xc0,
    0x72, 0x73, 0x8f, 0x7f, 0xee, 0x3b, 0x80, 0xef, 0xe1, 0xc0, 0x7a, 0xf3, 0xfe, 0x70, 0x0e, 0x3b,
    0x80, 0xee, 0xf1, 0xc0, 0x3f, 0xe3, 0xfc, 0x78, 0xee, 0x3b, 0x80, 0xee, 0x79, 0xff, 0x1f, 0xc3,
    0x80, 0x3f, 0xce, 0x3b, 0x80, 0xee, 0x3d, 0xff, 0x07, 0x03, 0x80, 0x1f, 0x8e, 0x3b, 0x80, 0xee,
    0x1d, 0xff, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t customSplash[] = {
    unpack_uint16(48), unpack_uint16(48),
    0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03,
    0xff, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xf8, 0x1f, 0xf0, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0xf8, 0x00,
    0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x7e, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0xfc, 0x1f, 0xf8,
    0x3f, 0x00, 0x00, 0xf8, 0x7f, 0xfe, 0x1f, 0x00, 0x01, 0xf0, 0xfc, 0x3f, 0x0f, 0x80, 0x01, 0xe1,
    0xf0, 0x0f, 0x87, 0x80, 0x03, 0xe3, 0xe0, 0x07, 0xc7, 0xc0, 0x03, 0xc3, 0xc0, 0x03, 0x03, 0xc0,
    0x07, 0xc7, 0x80, 0x00, 0x03, 0xe0, 0x07, 0x87, 0x80, 0x00, 0x01, 0xe0, 0x07, 0x8f, 0x00, 0x00,
    0x01, 0xe0, 0x0f, 0x8f, 0x00, 0x00, 0x01, 0xf0, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00,
    0x00, 0x00, 0x00, 0xf0, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x7b, 0xff, 0xff, 0xff,
    0xff, 0x0f, 0x7b, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x7b, 0xc0, 0x00, 0xf0, 0x0f, 0x0f, 0x7b, 0xc0,
    0x00, 0xf0, 0x0f, 0x80, 0x03, 0xc0, 0x01, 0xf0, 0x07, 0x8f, 0x7b, 0xc0, 0x01, 0xe0, 0x07, 0x8f,
    0x7b, 0xc0, 0x01, 0xe0, 0x07, 0xcf, 0x7b, 0xff, 0x83, 0xe0, 0x03, 0xcf, 0x7b, 0xff, 0x83, 0xc0,
    0x03, 0xe0, 0x03, 0xff, 0x87, 0xc0, 0x01, 0xe0, 0x03, 0xc0, 0x07, 0x80, 0x01, 0xf0, 0x03, 0xc0,
    0x0f, 0x80, 0x00, 0xf8, 0x03, 0xc0, 0x1f, 0x00, 0x00, 0x7c, 0x03, 0xc0, 0x3e, 0x00, 0x00, 0x7e,
    0x03, 0xc0, 0x7e, 0x00, 0x00, 0x3f, 0x03, 0xc0, 0xfc, 0x00, 0x00, 0x1f, 0xc3, 0xc3, 0xf8, 0x00,
    0x00, 0x07, 0xfb, 0xdf, 0xe0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00
};

Adafruit_SSD1306 *display;

GunDisplay::GunDisplay() {
}

void GunDisplay::drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], uint16_t color) {
    uint16_t w = ((uint16_t)bitmap[1] << 8) | bitmap[0];
    uint16_t h = ((uint16_t)bitmap[3] << 8) | bitmap[2];
    if (display)
        display->drawBitmap(x, y, &bitmap[4], w, h, color);
}

bool GunDisplay::setup() {
    display = new Adafruit_SSD1306(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire1, -1);

    if (display->begin(SSD1306_SWITCHCAPVCC, 0x3C, false)) {
        display->clearDisplay();
        ScreenModeChange(Screen_None);
        return true;
    } else {
        delete display;
        display = nullptr;
    }
    return false;
}

void GunDisplay::TopPanelUpdate(char *textPrefix, char *textInput) {
    if (!display)
        return;

    display->fillRect(0, 0, 128, 16, BLACK);
    display->drawFastHLine(0, 15, 128, WHITE);
    display->setCursor(2, 2);
    display->setTextSize(1);
    display->setTextColor(WHITE, BLACK);
    display->print(textPrefix);
    display->println(textInput);
    display->display();
}

void GunDisplay::ScreenModeChange(int8_t screenMode, bool isAnalog) {
    if (!display)
        return;

    display->fillRect(0, 16, 128, 48, BLACK);
    if (screenState >= Screen_Mamehook_Single && screenMode == Screen_Normal) {
        currentAmmo = 0, currentLife = 0;
    }
    screenState = screenMode;
    display->setTextColor(WHITE, BLACK);
    switch (screenMode) {
        case Screen_Normal:
            if (TinyUSBDevices.onBattery) {
                drawBitmap(2, 46, btConnectIco, WHITE);
            } else {
                drawBitmap(2, 46, usbConnectIco, WHITE);
            }
            if (isAnalog) {
                drawBitmap(108, 49, gamepadIco, WHITE);
            } else {
                drawBitmap(109, 48, mouseIco, WHITE);
            }
            break;
        case Screen_None:
        case Screen_Docked:
            display->fillRect(0, 0, 128, 16, BLACK);
            drawBitmap(24, 0, customSplashBanner, WHITE);
            drawBitmap(40, 16, customSplash, WHITE);
            display->display();
            break;
        case Screen_Init:
            display->setTextSize(2);
            display->setCursor(20, 18);
            display->println("Welcome!");
            display->setTextSize(1);
            display->setCursor(12, 40);
            display->println(" Pull trigger to");
            display->setCursor(12, 52);
            display->println("start calibration!");
            break;
        case Screen_IRTest:
            TopPanelUpdate("", "IR Test");
            break;
        case Screen_Saving:
            TopPanelUpdate("", "Saving Profiles");
            display->setTextSize(2);
            display->setCursor(16, 18);
            display->println("Saving...");
            break;
        case Screen_SaveSuccess:
            display->setTextSize(2);
            display->setCursor(30, 18);
            display->println("Save");
            display->setCursor(4, 40);
            display->println("successful");
            break;
        case Screen_SaveError:
            display->setTextSize(2);
            display->setCursor(30, 18);
            display->setTextColor(BLACK, WHITE);
            display->println("Save");
            display->setCursor(22, 40);
            display->println("failed");
            break;
        case Screen_Mamehook_Single:
            if (TinyUSBDevices.onBattery) {
                drawBitmap(2, 46, btConnectIco, WHITE);
            } else {
                drawBitmap(2, 46, usbConnectIco, WHITE);
            }
            if (isAnalog) {
                drawBitmap(108, 49, gamepadIco, WHITE);
            } else {
                drawBitmap(109, 48, mouseIco, WHITE);
            }
            if (serialDisplayType == ScreenSerial_Life && lifeBar) {
                drawBitmap(52, 23, lifeBarBanner, WHITE);
                drawBitmap(11, 35, lifeBarLarge, WHITE);
                PrintLife(currentLife);
            } else if (serialDisplayType == ScreenSerial_Ammo) {
                PrintAmmo(currentAmmo);
            } else {
                drawBitmap(0, 17, mamehookIco, WHITE);
            }
            break;
        case Screen_Mamehook_Dual:
            drawBitmap(63, 16, dividerLine, WHITE);
            if (lifeBar) {
                drawBitmap(20, 23, lifeBarBanner, WHITE);
                drawBitmap(2, 37, lifeBarSmall, WHITE);
            }
            PrintAmmo(currentAmmo);
            PrintLife(currentLife);
            break;
    }
    display->display();
}

void GunDisplay::IdleOps() {
    if (!display)
        return;
    switch (screenState) {
        case Screen_Normal:
            break;
        case Screen_Pause:
            break;
        case Screen_Profile:
            break;
        case Screen_Saving:
            break;
        case Screen_Calibrating:
            break;
        case Screen_Mamehook_Single:
            break;
        case Screen_Mamehook_Dual:
            break;
    }
}

// Warning: SLOOOOW, should only be used in cali/where the mouse isn't being updated.
// Use at your own discression.
void GunDisplay::DrawVisibleIR(int pointX[4], int pointY[4]) {
    if (!display)
        return;

    display->fillRect(0, 16, 128, 48, BLACK);
    for (uint8_t i = 0; i < 4; i++) {
        pointX[i] = map(pointX[i], 0, 1920, 0, 128);
        pointY[i] = map(pointY[i], 0, 1080, 16, 64);
        pointY[i] = constrain(pointY[i], 16, 64);
        display->fillCircle(pointX[i], pointY[i], 1, WHITE);
    }
    display->display();
}

void GunDisplay::PauseScreenShow(uint8_t currentProf, char *profiles[]) {
    if (!display)
        return;

    TopPanelUpdate("Using ", profiles[currentProf]);
    display->fillRect(0, 16, 128, 48, BLACK);
    display->setTextSize(1);

    display->setCursor(0, 17);
    display->print(" A > ");
    display->println(name1);
    display->setCursor(0, 17 + 11);
    display->print(" B > ");
    display->println(name2);
    display->setCursor(0, 17 + (11 * 2));
    display->print("Str> ");
    display->println(name3);
    display->setCursor(0, 17 + (11 * 3));
    display->print("Sel> ");
    display->println(name4);
    display->display();
}

void GunDisplay::PauseListUpdate(uint8_t selection) {
    if (!display)
        return;

    const char *menus[]  = {" Calibrate ",     " Profile Select ",  " Save Gun Settings ",
                            " Rumble Toggle ", " Solenoid Toggle ", " Send Escape Keypress"};
    uint8_t     idx      = (selection - 1) % ARRAY_SIZE(menus);
    text_t      lines[3] = {{false, 0, 25, (char *)menus[idx]},
                            {true, 0, 36, (char *)menus[(idx + 1) % ARRAY_SIZE(menus)]},
                            {false, 0, 47, (char *)menus[(idx + 2) % ARRAY_SIZE(menus)]}};

    display->fillRect(0, 16, 128, 48, BLACK);
    drawBitmap(60, 18, upArrowGlyph, WHITE);
    drawBitmap(60, 59, downArrowGlyph, WHITE);
    display->setTextSize(1);
    for (uint8_t i = 0; i < 3; i++) {
        display->setTextColor(lines[i].inverse ? BLACK : WHITE, lines[i].inverse ? WHITE : BLACK);
        display->setCursor(lines[i].x, lines[i].y);
        display->println(lines[i].text);
    }
    display->display();
}

void GunDisplay::PauseProfileUpdate(uint8_t selection, char   *profiles[]) {
    if (!display)
        return;

    uint8_t idx     = (selection - 1) % 4;
    text_t  lines[] = {
        {false, 4, 25, profiles[idx]},
        {true, 4, 36, profiles[(idx + 1) % 4]},
        {false, 4, 47, profiles[(idx + 2) % 4]}
    };

    display->fillRect(0, 16, 128, 48, BLACK);
    drawBitmap(60, 18, upArrowGlyph, WHITE);
    drawBitmap(60, 59, downArrowGlyph, WHITE);

    display->setTextSize(1);
    for (uint8_t i = 0; i < 3; i++) {
        display->setTextColor(lines[i].inverse ? BLACK : WHITE, lines[i].inverse ? WHITE : BLACK);
        display->setCursor(lines[i].x, lines[i].y);
        display->println(lines[i].text);
    }
    display->display();
}

void GunDisplay::SaveScreen(uint8_t status) {
    if (!display)
        return;

    display->fillRect(0, 16, 128, 48, BLACK);
    display->setTextColor(WHITE, BLACK);
    display->setTextSize(2);
    display->setCursor(24, 24);
    display->println("Saving...");
    display->display();
}

void GunDisplay::PrintAmmo(uint8_t ammo) {
    if (!display)
        return;

    currentAmmo = ammo;
    // use the rounding error to get the left & right digits
    uint8_t ammoLeft  = ammo / 10;
    uint8_t ammoRight = ammo - ammoLeft * 10;
    ammoEmpty = !ammo;

    uint16_t w = bitmap_width(number_0);
    uint16_t h = bitmap_height(number_0);
    if (screenState == Screen_Mamehook_Single) {
        display->fillRect(40, 22, w, h, BLACK);
        drawBitmap(40, 22, numbers[ammoLeft], WHITE);
        display->fillRect(40 + w + 6, 22, w, h, BLACK);
        drawBitmap(40 + w + 6, 22, numbers[ammoRight], WHITE);
        display->display();
    } else if (screenState == Screen_Mamehook_Dual) {
        display->fillRect(72, 22, w, h, BLACK);
        drawBitmap(72, 22, numbers[ammoLeft], WHITE);
        display->fillRect(72 + w + 6, 22, w, h, BLACK);
        drawBitmap(72 + w + 6, 22, numbers[ammoRight], WHITE);
        display->display();
    }
}

void GunDisplay::PrintLife(uint8_t life) {
    if (!display)
        return;

    currentLife = life;
    lifeEmpty = !life;

    if (screenState == Screen_Mamehook_Single) {
        if (lifeBar) {
            display->fillRect(14, 37, 100, 9, BLACK);
            display->fillRect(52, 51, 30, 8, BLACK);
            display->fillRect(14, 37, life, 9, WHITE);
            if (life) {
                display->setTextSize(1);
                display->setCursor(52, 51);
                display->setTextColor(WHITE, BLACK);
                display->print(life);
                display->println(" %");
            }
        } else {
            uint16_t w       = bitmap_width(lifeIcoLarge);
            uint16_t h       = bitmap_height(lifeIcoLarge);
            uint16_t l1_x    = 22;
            uint16_t l1_y    = 19;
            uint16_t l2_x[5] = {56, 48, 39, 30, 22};
            uint16_t l2_y    = (life > 5) ? 41 : 30;

            display->fillRect(l1_x, l1_y, w * 5 + 4, h + 22 + h, BLACK);
            if (life > 5) {
                uint16_t x = l1_x;
                for (uint8_t i = 0; i < 5; i++) {
                    drawBitmap(x, l1_y, lifeIcoLarge, WHITE);
                    x += (w + 1);
                }
                life = min(life - 5, 5);
            }
            if (life > 0) {
                uint16_t x = l2_x[life - 1];
                for (uint8_t i = 0; i < life; i++) {
                    drawBitmap(x, l2_y, lifeIcoLarge, WHITE);
                    x += (w + 1);
                }
            }
        }
    } else if (screenState == Screen_Mamehook_Dual) {
        if (lifeBar) {
            display->fillRect(4, 39, 55, 5, BLACK);
            display->fillRect(20, 51, 30, 8, BLACK);
            display->fillRect(4, 39, map(life, 0, 100, 0, 55), 5, WHITE);
            if (life) {
                display->setTextSize(1);
                display->setCursor(20, 51);
                display->setTextColor(WHITE, BLACK);
                display->print(life);
                display->println(" %");
            }
        } else {
            uint16_t w       = bitmap_width(lifeIcoSmall);
            uint16_t h       = bitmap_height(lifeIcoSmall);
            uint16_t l1_x    = 1;
            uint16_t l1_y    = 22;
            uint16_t l2_x[5] = {25, 19, 13, 7, 1};
            uint16_t l2_y    = (life > 5) ? 42 : 32;

            display->fillRect(1, 22, w * 5, h + 20 + h, BLACK);
            if (life > 5) {
                uint16_t x = l1_x;
                for (uint8_t i = 0; i < 5; i++) {
                    drawBitmap(x, l1_y, lifeIcoLarge, WHITE);
                    x += w;
                }
                life = min(life - 5, 5);
            }
            if (life > 0) {
                uint16_t x = l2_x[life - 1];
                for (uint8_t i = 0; i < life; i++) {
                    drawBitmap(x, l2_y, lifeIcoLarge, WHITE);
                    x += w;
                }
            }
        }
        display->display();
    }
}
