#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>
#include "GunDisplay.h"

#define unpack_uint16(x)    ((x >> 0) & 0xff), ((x >> 8) & 0xff)
#define bitmap_width(x)     (x[0] | ((uint16_t)x[1] << 8))
#define bitmap_height(x)    (x[2] | ((uint16_t)x[3] << 8))

/// @brief Glyphs for common HUD elements
static const uint8_t number_0[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xd0, 0xe0, 0x00, 0x78, 0xe0, 0x00, 0xf8, 0xe0,
    0x00, 0xf8, 0xe0, 0x01, 0xb8, 0xe0, 0x01, 0xb8, 0xe0, 0x03, 0x38, 0xe0, 0x03, 0x38, 0xe0, 0x06,
    0x38, 0xe0, 0x06, 0x38, 0xe0, 0x0c, 0x38, 0xe0, 0x0c, 0x38, 0xe0, 0x18, 0x38, 0xe0, 0x18, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0xb8, 0xe0, 0x60, 0x38, 0xe0, 0x60, 0x38, 0xe0,
    0xc0, 0x38, 0xe0, 0xc0, 0x38, 0xe1, 0x80, 0x38, 0xe1, 0x80, 0x38, 0xe3, 0x00, 0x38, 0xe3, 0x00,
    0x38, 0xe6, 0x00, 0x38, 0xe6, 0x00, 0x38, 0xec, 0x00, 0x38, 0xec, 0x00, 0x38, 0xf8, 0x00, 0x38,
    0xf8, 0x00, 0x38, 0x5f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_1[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t number_2[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xd0, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x0f, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0x80, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0,
    0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0xe0, 0x00, 0x00, 0x5f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_3[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xd0, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x0f, 0xff, 0xb8, 0x1f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x1f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_4[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x10, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t number_5[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xc0, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0,
    0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0xef, 0xff, 0x80, 0x5f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x1f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_6[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xc0, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0,
    0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0xef, 0xff, 0x80, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0xb8, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xe0, 0x00, 0x38, 0x5f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_7[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0xc0, 0x00,
    0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x06,
    0x00, 0x00, 0x06, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00,
    0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00, 0x60, 0x00, 0x00,
    0xc0, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x06, 0x00, 0x00, 0x06, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x18, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t number_8[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xd0, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0xef, 0xff, 0xb8, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xe0, 0x00, 0x38, 0x5f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t number_9[] = {
    unpack_uint16(21), unpack_uint16(36),
    0x1f, 0xff, 0xc0, 0x3f, 0xff, 0xe0, 0x5f, 0xff, 0xd0, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0,
    0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00,
    0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38, 0xe0, 0x00, 0x38,
    0xef, 0xff, 0xb8, 0x5f, 0xff, 0xd0, 0x0f, 0xff, 0xb8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38, 0x00, 0x00, 0x38,
    0x00, 0x00, 0x38, 0x1f, 0xff, 0xd0, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xc0
};

static const uint8_t *numbers[] = {
    number_0,
    number_1,
    number_2,
    number_3,
    number_4,
    number_5,
    number_6,
    number_7,
    number_8,
    number_9
};

static const uint8_t lifeIcoSmall[] = {
    unpack_uint16(12), unpack_uint16(16),
    0xff, 0xf0, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0x90, 0x90, 0xb9, 0xd0, 0xbf, 0xd0, 0xbf, 0xd0,
    0xbf, 0xd0, 0x9f, 0x90, 0x8f, 0x10, 0x86, 0x10, 0x80, 0x10, 0x80, 0x10, 0x80, 0x10, 0xff, 0xf0
};

static const uint8_t lifeIcoLarge[] = {
    unpack_uint16(16), unpack_uint16(20),
    0xff, 0xff, 0xc0, 0x03, 0xbf, 0xfd, 0xa0, 0x05, 0xa0, 0x05, 0xa0, 0x05, 0xa4, 0x25, 0xae, 0x75,
    0xaf, 0xf5, 0xaf, 0xf5, 0xaf, 0xf5, 0xa7, 0xe5, 0xa3, 0xc5, 0xa1, 0x85, 0xa0, 0x05, 0xa0, 0x05,
    0xa0, 0x05, 0xbf, 0xfd, 0xc0, 0x03, 0xff, 0xff
};

static const uint8_t lifeBarBanner[] = {
    unpack_uint16(23), unpack_uint16(9),
    0xc1, 0xbf, 0x7e, 0xc1, 0xbf, 0x7e, 0xc1, 0xb8, 0x60, 0xc1, 0xb0, 0x60, 0xc1, 0xbe, 0x7c, 0xc1,
    0xbe, 0x60, 0xc1, 0xb0, 0x60, 0xfd, 0xb0, 0x7e, 0xfd, 0xb0, 0x7e
};

static const uint8_t lifeBarSmall[] = {
    unpack_uint16(59), unpack_uint16(9),
    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80
};

static const uint8_t lifeBarLarge[] = {
    unpack_uint16(106), unpack_uint16(13),
    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x3f, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0,
    0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xfe, 0x00
};

static const uint8_t reloadGlyph[] = {
    // RELOAD
};

// if only we could draw this vertically, sigh
static const uint8_t dividerLine[] = {
    unpack_uint16(1), unpack_uint16(48),
    0x40, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
    0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
    0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00
};

static const uint8_t upArrowGlyph[] = {
    unpack_uint16(9), unpack_uint16(5),
    0x08, 0x00, 0x14, 0x00, 0x22, 0x00, 0x41, 0x00, 0x80, 0x80
};

static const uint8_t downArrowGlyph[] = {
    unpack_uint16(9), unpack_uint16(5),
    0x80, 0x80, 0x41, 0x00, 0x22, 0x00, 0x14, 0x00, 0x08, 0x00
};

static const uint8_t btConnectIco[] = {
    unpack_uint16(10), unpack_uint16(17),
    0x18, 0x00, 0x1c, 0x00, 0x1e, 0x00, 0x1b, 0x00, 0xd9, 0x80, 0x78, 0xc0, 0x39, 0x80, 0x1b, 0x00,
    0x1e, 0x00, 0x1b, 0x00, 0x39, 0x80, 0x78, 0xc0, 0xd9, 0x80, 0x1b, 0x00, 0x1e, 0x00, 0x1c, 0x00,
    0x18, 0x00
};

static const uint8_t usbConnectIco[] = {
    unpack_uint16(10), unpack_uint16(17),
    0x3f, 0x00, 0x2d, 0x00, 0x2d, 0x00, 0x2d, 0x00, 0x7f, 0x80, 0xc0, 0xc0, 0x88, 0x40, 0x9c, 0x40,
    0x89, 0x40, 0xa9, 0x40, 0xaa, 0x40, 0xac, 0x40, 0x98, 0x40, 0x88, 0x40, 0x80, 0x40, 0xff, 0xc0,
    0x7f, 0x80
};

static const uint8_t gamepadIco[] = {
    unpack_uint16(18), unpack_uint16(12),
    0x38, 0x07, 0x00, 0x7d, 0xef, 0x80, 0x42, 0x10, 0x80, 0x80, 0x00, 0x40, 0x91, 0x22, 0x40, 0xb8,
    0x05, 0x40, 0x93, 0x32, 0x40, 0x84, 0xc8, 0x40, 0x84, 0xc8, 0x40, 0x87, 0x38, 0x40, 0x44, 0x08,
    0x80, 0x38, 0x07, 0x00
};

static const uint8_t mouseIco[] = {
    unpack_uint16(16), unpack_uint16(13),
    0x06, 0x00, 0x09, 0x03, 0x10, 0x84, 0x7c, 0x48, 0x92, 0x48, 0x92, 0x30, 0x92, 0x00, 0xfe, 0x00,
    0x82, 0x00, 0x82, 0x00, 0x82, 0x00, 0x44, 0x00, 0x38, 0x00
};

static const uint8_t mamehookIco[] = {
    unpack_uint16(21), unpack_uint16(16),
    0x00, 0x02, 0x08, 0x00, 0x06, 0x18, 0x00, 0x0e, 0x38, 0x00, 0x1a, 0x68, 0x00, 0x32, 0xc8, 0x00,
    0x63, 0x88, 0x00, 0xc3, 0x08, 0x01, 0x82, 0x08, 0x03, 0x00, 0x08, 0x06, 0x10, 0x08, 0x0c, 0x30,
    0x88, 0x18, 0x71, 0x88, 0x30, 0xb3, 0x88, 0x61, 0x35, 0x88, 0xc2, 0x39, 0x88, 0xfc, 0x31, 0xf8
};

static const uint8_t customSplashBanner[] = {
    unpack_uint16(80), unpack_uint16(16),
    0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xef, 0xf1, 0xff, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x03,
    0xfe, 0xef, 0xf9, 0xff, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xef, 0xf9, 0xc0, 0x7a, 0xf0,
    0x00, 0x00, 0x00, 0x03, 0x80, 0xee, 0x1d, 0xc0, 0x72, 0x73, 0xfc, 0x1f, 0x8f, 0xf3, 0x80, 0xee,
    0x0d, 0xc0, 0xe2, 0x3b, 0xfe, 0x3f, 0xcf, 0xfb, 0xfe, 0xee, 0x1d, 0xff, 0xff, 0xfb, 0x8f, 0x78,
    0xef, 0xfb, 0xfe, 0xef, 0xf9, 0xff, 0xe2, 0x3b, 0x87, 0x70, 0x6e, 0x7b, 0xfe, 0xef, 0xf9, 0xc0,
    0x72, 0x73, 0x8f, 0x7f, 0xee, 0x3b, 0x80, 0xef, 0xe1, 0xc0, 0x7a, 0xf3, 0xfe, 0x70, 0x0e, 0x3b,
    0x80, 0xee, 0xf1, 0xc0, 0x3f, 0xe3, 0xfc, 0x78, 0xee, 0x3b, 0x80, 0xee, 0x79, 0xff, 0x1f, 0xc3,
    0x80, 0x3f, 0xce, 0x3b, 0x80, 0xee, 0x3d, 0xff, 0x07, 0x03, 0x80, 0x1f, 0x8e, 0x3b, 0x80, 0xee,
    0x1d, 0xff, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t customSplash[] = {
    unpack_uint16(48), unpack_uint16(48),
    0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03,
    0xff, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xf8, 0x1f, 0xf0, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0xf8, 0x00,
    0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x7e, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0xfc, 0x1f, 0xf8,
    0x3f, 0x00, 0x00, 0xf8, 0x7f, 0xfe, 0x1f, 0x00, 0x01, 0xf0, 0xfc, 0x3f, 0x0f, 0x80, 0x01, 0xe1,
    0xf0, 0x0f, 0x87, 0x80, 0x03, 0xe3, 0xe0, 0x07, 0xc7, 0xc0, 0x03, 0xc3, 0xc0, 0x03, 0x03, 0xc0,
    0x07, 0xc7, 0x80, 0x00, 0x03, 0xe0, 0x07, 0x87, 0x80, 0x00, 0x01, 0xe0, 0x07, 0x8f, 0x00, 0x00,
    0x01, 0xe0, 0x0f, 0x8f, 0x00, 0x00, 0x01, 0xf0, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00,
    0x00, 0x00, 0x00, 0xf0, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x7b, 0xff, 0xff, 0xff,
    0xff, 0x0f, 0x7b, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x7b, 0xc0, 0x00, 0xf0, 0x0f, 0x0f, 0x7b, 0xc0,
    0x00, 0xf0, 0x0f, 0x80, 0x03, 0xc0, 0x01, 0xf0, 0x07, 0x8f, 0x7b, 0xc0, 0x01, 0xe0, 0x07, 0x8f,
    0x7b, 0xc0, 0x01, 0xe0, 0x07, 0xcf, 0x7b, 0xff, 0x83, 0xe0, 0x03, 0xcf, 0x7b, 0xff, 0x83, 0xc0,
    0x03, 0xe0, 0x03, 0xff, 0x87, 0xc0, 0x01, 0xe0, 0x03, 0xc0, 0x07, 0x80, 0x01, 0xf0, 0x03, 0xc0,
    0x0f, 0x80, 0x00, 0xf8, 0x03, 0xc0, 0x1f, 0x00, 0x00, 0x7c, 0x03, 0xc0, 0x3e, 0x00, 0x00, 0x7e,
    0x03, 0xc0, 0x7e, 0x00, 0x00, 0x3f, 0x03, 0xc0, 0xfc, 0x00, 0x00, 0x1f, 0xc3, 0xc3, 0xf8, 0x00,
    0x00, 0x07, 0xfb, 0xdf, 0xe0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00
};



static Adafruit_SSD1306 *display;

void GunDisplay::drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], uint16_t color) {
    uint16_t w = ((uint16_t)bitmap[1] << 8) | bitmap[0];
    uint16_t h = ((uint16_t)bitmap[3] << 8) | bitmap[2];

    if (display)
        display->drawBitmap(x, y, &bitmap[4], w, h, color);
}

bool GunDisplay::setup(TwoWire *wire) {
    display = new Adafruit_SSD1306(SCREEN_WIDTH, SCREEN_HEIGHT, wire, -1);

    if (display->begin(SSD1306_SWITCHCAPVCC, 0x3C, false)) {
        display->clearDisplay();
        // display->display();
        // ScreenModeChange(Screen_None);
        return true;
    } else {
        delete display;
        display = nullptr;
    }
    return false;
}

void GunDisplay::draw_menu(GunMenu *menu) {
    if (!display)
        return;

    int8_t idx;
    int8_t idx_sel;
    std::vector<GunMenu::menu_item> *list = menu->get_list();

    display->clearDisplay();
    display->setTextColor(WHITE, BLACK);
    display->setCursor(0, 2);
    display->setTextSize(1);
    draw_centered_text(menu->title());
    display->drawFastHLine(0, 10, 128, WHITE);

    if (list->size() > 1) {
        idx = menu->get_pos() - 1;
        if (idx < 0) {
            idx = idx + list->size();
        }
        idx_sel = 1;
    } else {
        idx = 0;
        idx_sel = -1;
    }

    char *buf = new char[255];
    for (int i = 0; i < min(3, (int)list->size()); i++) {
        if (i == idx_sel) {
            display->fillRect(0, 20 + i * 14, display->width() - 10, 8, WHITE);
            display->setTextColor(BLACK, WHITE);
        } else {
            display->setTextColor(WHITE, BLACK);
        }
        display->setCursor(0, 20 + i * 14);
        list->at(idx).format(&buf, 255);
        if (list->at(idx).get_type() == GunMenu::TYPE_CENTER_STR)
            draw_centered_text(buf);
        else
            display->println(buf);
        idx = (idx + 1)  % list->size();
    }
    delete buf;

    if (list->size() > 1) {
        drawBitmap(118, 18, upArrowGlyph, WHITE);
        drawBitmap(118, 59, downArrowGlyph, WHITE);
    }
    display->display();
}

void GunDisplay::tokenize(char *line, char *token, std::vector<char *> &tokens) {
    char *tkn = strtok(line, token);

    while (tkn != NULL) {
        tokens.push_back(tkn);
        tkn = strtok(NULL, token);
    }
}

void GunDisplay::draw_centered_text(char *text, uint8_t flag) {
    int16_t     x1, y1;
    uint16_t    w, h;

    std::vector<char *> tokens;
    tokenize((char *)text, (char *)"\n", tokens);

    int16_t x;
    int16_t y = display->getCursorY();
    for (char *str:tokens) {
        display->getTextBounds(str, 0, y, &x1, &y1, &w, &h);

        // if (flag & FLAG_HALF_LEFT) {
        //     x = (display->width() / 2 - w) / 2;
        // } else if (flag & FLAG_HALF_RIGHT) {
        //     x = (display->width() / 2) + (display->width() / 2 - w) / 2;
        // } else {
        //     x = (display->width() - w) / 2;
        // }
        x = (display->width() - w) / 2;
        display->setCursor(x, y);
        display->print(str);
        y += h;

        if (str != text && *(str - 1)=='\0')
            *(str - 1) = '\n';
    }
}

void GunDisplay::TopPanelUpdate(char *textPrefix, char *textInput) {
    if (!display)
        return;

    display->fillRect(0, 0, 128, 16, BLACK);
    display->drawFastHLine(0, 15, 128, WHITE);
    display->setCursor(2, 2);
    display->setTextSize(1);
    display->setTextColor(WHITE, BLACK);
    display->print(textPrefix);
    display->println(textInput);
    display->display();
}


#if 0
void GunDisplay::ScreenModeChange(int8_t screenMode, bool isAnalog, bool isBT) {
    if (!display)
        return;

    const text_t  menu_init[] = {
        {false, 2, 20, 18, "Welcome!\nPull trigger to\nstart calibration!"},
        {false, 1, 12, 40, " Pull trigger to"},
        {false, 1, 12, 52, "start calibration!"},
        {false, 0, 0, 0, NULL},
    };
    const text_t  menu_saving[] = {
        {false, 2, 16, 18, "Saving..."},
        {false, 0, 0, 0, NULL},
    };
    const text_t  menu_save_success[] = {
        {false, 2, 30, 18, "Save"},
        {false, 4, 40, 18, "successful"},
        {false, 0, 0, 0, NULL},
    };
    const text_t  menu_save_error[] = {
        {true, 2, 30, 18, "Save"},
        {true, 22, 40, 18, "failed"},
        {false, 0, 0, 0, NULL},
    };
    text_t *menu = NULL;


    display->fillRect(0, 16, 128, 48, BLACK);
    if (screenState >= Screen_Mamehook_Single && screenMode == Screen_Normal) {
        currentAmmo = 0;
        currentLife = 0;
    }
    screenState = screenMode;

    display->setTextColor(WHITE, BLACK);
    switch (screenMode) {
        case Screen_Normal:
            drawBitmap(2, 46, isBT ? btConnectIco : usbConnectIco, WHITE);
            drawBitmap(108, 49, isAnalog ? gamepadIco : mouseIco, WHITE);
            break;
        case Screen_None:
        case Screen_Docked:
            display->fillRect(0, 0, 128, 16, BLACK);
            drawBitmap(24, 0, customSplashBanner, WHITE);
            drawBitmap(40, 16, customSplash, WHITE);
            break;
        case Screen_Init:
            menu = (text_t *)menu_init;
            break;
        case Screen_IRTest:
            TopPanelUpdate("", "IR Test");
            break;
        case Screen_Saving:
            TopPanelUpdate("", "Saving Profiles");
            menu = (text_t *)menu_saving;
            break;
        case Screen_SaveSuccess:
            menu = (text_t *)menu_save_success;
            break;
        case Screen_SaveError:
            menu = (text_t *)menu_save_error;
            break;
        case Screen_Mamehook_Single:
            drawBitmap(2, 46, isBT ? btConnectIco : usbConnectIco, WHITE);
            drawBitmap(108, 49, isAnalog ? gamepadIco : mouseIco, WHITE);
            if (serialDisplayType == ScreenSerial_Life && lifeBar) {
                drawBitmap(52, 23, lifeBarBanner, WHITE);
                drawBitmap(11, 35, lifeBarLarge, WHITE);
                drawLife(currentLife);
            } else if (serialDisplayType == ScreenSerial_Ammo) {
                drawAmmo(currentAmmo);
            } else {
                drawBitmap(0, 17, mamehookIco, WHITE);
            }
            break;
        case Screen_Mamehook_Dual:
            drawBitmap(63, 16, dividerLine, WHITE);
            if (lifeBar) {
                drawBitmap(20, 23, lifeBarBanner, WHITE);
                drawBitmap(2, 37, lifeBarSmall, WHITE);
            }
            drawAmmo(currentAmmo);
            drawLife(currentLife);
            break;
    }
    if (menu)
        draw_menu(menu);
    display->display();
}

void GunDisplay::IdleOps() {
    if (!display)
        return;
    switch (screenState) {
        case Screen_Normal:
            break;
        case Screen_Pause:
            break;
        case Screen_Profile:
            break;
        case Screen_Saving:
            break;
        case Screen_Calibrating:
            break;
        case Screen_Mamehook_Single:
            break;
        case Screen_Mamehook_Dual:
            break;
    }
}

void GunDisplay::PauseScreenShow(uint8_t currentProf, char *profiles[]) {
    if (!display)
        return;

    const char *texts[4] = {
        " A > ",
        " B > ",
        "Str> ",
        "Sel> "
    };

    TopPanelUpdate("Using ", profiles[currentProf]);
    display->fillRect(0, 16, 128, 48, BLACK);
    display->setTextSize(1);
    for (uint8_t i = 0; i < ARRAY_SIZE(texts); i++) {
        display->setCursor(0, 17 + 11 * i);
        display->print(texts[i]);
        display->println(profiles[i]);
    }
    display->display();
}

void GunDisplay::PauseListUpdate(uint8_t selection) {
    if (!display)
        return;

    const char   *menus[]  = {" Calibrate ",     " Profile Select ",  " Save Gun Settings ",
                              " Rumble Toggle ", " Solenoid Toggle ", " Send Escape Keypress"};
    const uint8_t idx      = (selection - 1) % ARRAY_SIZE(menus);
    const text_t  lines[]  = {
        {false, 1, 0, 25, (char *)menus[idx]},
        {true, 1, 0, 36, (char *)menus[(idx + 1) % ARRAY_SIZE(menus)]},
        {false, 1, 0, 47, (char *)menus[(idx + 2) % ARRAY_SIZE(menus)]},
        {false, 0, 0, 0, NULL}
    };

    display->fillRect(0, 16, 128, 48, BLACK);
    drawBitmap(60, 18, upArrowGlyph, WHITE);
    drawBitmap(60, 59, downArrowGlyph, WHITE);
    draw_menu((text_t*)lines);
    display->display();
}

void GunDisplay::PauseProfileUpdate(uint8_t selection, char *profiles[]) {
    if (!display)
        return;

    const uint8_t idx     = (selection - 1) % 4;
    const text_t  lines[] = {
        {false, 1, 4, 25, profiles[idx]},
        {true,  1, 4, 36, profiles[(idx + 1) % 4]},
        {false, 1, 4, 47, profiles[(idx + 2) % 4]},
        {false, 0, 0, 0, NULL}
    };

    display->fillRect(0, 16, 128, 48, BLACK);
    drawBitmap(60, 18, upArrowGlyph, WHITE);
    drawBitmap(60, 59, downArrowGlyph, WHITE);
    draw_menu((text_t*)lines);
    display->display();
}

void GunDisplay::SaveScreen(uint8_t status) {
    if (!display)
        return;

    display->fillRect(0, 16, 128, 48, BLACK);
    display->setTextColor(WHITE, BLACK);
    display->setTextSize(2);
    display->setCursor(24, 24);
    display->println("Saving...");
    display->display();
}

#endif

// Warning: SLOOOOW, should only be used in cali/where the mouse isn't being updated.
// Use at your own discression.
void GunDisplay::DrawVisibleIR(int pointX[4], int pointY[4]) {
    if (!display)
        return;

    display->fillRect(0, 16, 128, 48, BLACK);
    for (uint8_t i = 0; i < 4; i++) {
        pointX[i] = map(pointX[i], 0, 1920, 0, 128);
        pointY[i] = map(pointY[i], 0, 1080, 16, 64);
        pointY[i] = constrain(pointY[i], 16, 64);
        display->fillCircle(pointX[i], pointY[i], 1, WHITE);
    }
    display->display();
}

void GunDisplay::drawAmmo(uint8_t ammo) {
    if (!display)
        return;

    currentAmmo = ammo;
    // use the rounding error to get the left & right digits
    uint8_t ammoLeft  = ammo / 10;
    uint8_t ammoRight = ammo - ammoLeft * 10;
    ammoEmpty         = !ammo;

    uint16_t w = bitmap_width(number_0);
    uint16_t h = bitmap_height(number_0);
    if (screenState == Screen_Mamehook_Single) {
        display->fillRect(40, 22, w, h, BLACK);
        drawBitmap(40, 22, numbers[ammoLeft], WHITE);
        display->fillRect(40 + w + 6, 22, w, h, BLACK);
        drawBitmap(40 + w + 6, 22, numbers[ammoRight], WHITE);
        display->display();
    } else if (screenState == Screen_Mamehook_Dual) {
        display->fillRect(72, 22, w, h, BLACK);
        drawBitmap(72, 22, numbers[ammoLeft], WHITE);
        display->fillRect(72 + w + 6, 22, w, h, BLACK);
        drawBitmap(72 + w + 6, 22, numbers[ammoRight], WHITE);
        display->display();
    }
}

void GunDisplay::drawLife(uint8_t life) {
    if (!display)
        return;

    currentLife = life;
    lifeEmpty   = !life;

    if (screenState == Screen_Mamehook_Single) {
        if (lifeBar) {
            display->fillRect(14, 37, 100, 9, BLACK);
            display->fillRect(52, 51, 30, 8, BLACK);
            display->fillRect(14, 37, life, 9, WHITE);
            if (life) {
                display->setTextSize(1);
                display->setCursor(52, 51);
                display->setTextColor(WHITE, BLACK);
                display->print(life);
                display->println(" %");
            }
        } else {
            uint16_t w       = bitmap_width(lifeIcoLarge);
            uint16_t h       = bitmap_height(lifeIcoLarge);
            uint16_t l1_x    = 22;
            uint16_t l1_y    = 19;
            uint16_t l2_x[5] = {56, 48, 39, 30, 22};
            uint16_t l2_y    = (life > 5) ? 41 : 30;

            display->fillRect(l1_x, l1_y, w * 5 + 4, h + 22 + h, BLACK);
            if (life > 5) {
                uint16_t x = l1_x;
                for (uint8_t i = 0; i < 5; i++) {
                    drawBitmap(x, l1_y, lifeIcoLarge, WHITE);
                    x += (w + 1);
                }
                life = min(life - 5, 5);
            }
            if (life > 0) {
                uint16_t x = l2_x[life - 1];
                for (uint8_t i = 0; i < life; i++) {
                    drawBitmap(x, l2_y, lifeIcoLarge, WHITE);
                    x += (w + 1);
                }
            }
        }
    } else if (screenState == Screen_Mamehook_Dual) {
        if (lifeBar) {
            display->fillRect(4, 39, 55, 5, BLACK);
            display->fillRect(20, 51, 30, 8, BLACK);
            display->fillRect(4, 39, map(life, 0, 100, 0, 55), 5, WHITE);
            if (life) {
                display->setTextSize(1);
                display->setCursor(20, 51);
                display->setTextColor(WHITE, BLACK);
                display->print(life);
                display->println(" %");
            }
        } else {
            uint16_t w       = bitmap_width(lifeIcoSmall);
            uint16_t h       = bitmap_height(lifeIcoSmall);
            uint16_t l1_x    = 1;
            uint16_t l1_y    = 22;
            uint16_t l2_x[5] = {25, 19, 13, 7, 1};
            uint16_t l2_y    = (life > 5) ? 42 : 32;

            display->fillRect(1, 22, w * 5, h + 20 + h, BLACK);
            if (life > 5) {
                uint16_t x = l1_x;
                for (uint8_t i = 0; i < 5; i++) {
                    drawBitmap(x, l1_y, lifeIcoLarge, WHITE);
                    x += w;
                }
                life = min(life - 5, 5);
            }
            if (life > 0) {
                uint16_t x = l2_x[life - 1];
                for (uint8_t i = 0; i < life; i++) {
                    drawBitmap(x, l2_y, lifeIcoLarge, WHITE);
                    x += w;
                }
            }
        }
        display->display();
    }
}
